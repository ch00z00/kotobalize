/* tslint:disable */
/* eslint-disable */
/**
 * Kotobalize API
 * API for the Kotobalize technical interview preparation app.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface AuthResponse
 */
export interface AuthResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthResponse
     */
    'token': string;
    /**
     * 
     * @type {User}
     * @memberof AuthResponse
     */
    'user': User;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface NewReviewRequest
 */
export interface NewReviewRequest {
    /**
     * 
     * @type {number}
     * @memberof NewReviewRequest
     */
    'writingId': number;
}
/**
 * 
 * @export
 * @interface NewThemeRequest
 */
export interface NewThemeRequest {
    /**
     * 
     * @type {string}
     * @memberof NewThemeRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof NewThemeRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof NewThemeRequest
     */
    'category': string;
}
/**
 * 
 * @export
 * @interface NewWritingRequest
 */
export interface NewWritingRequest {
    /**
     * 
     * @type {number}
     * @memberof NewWritingRequest
     */
    'themeId': number;
    /**
     * 
     * @type {string}
     * @memberof NewWritingRequest
     */
    'content': string;
    /**
     * 
     * @type {number}
     * @memberof NewWritingRequest
     */
    'durationSeconds': number;
}
/**
 * 
 * @export
 * @interface RegisterRequest
 */
export interface RegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Theme
 */
export interface Theme {
    /**
     * 
     * @type {number}
     * @memberof Theme
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Theme
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Theme
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Theme
     */
    'category': string;
    /**
     * 
     * @type {string}
     * @memberof Theme
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Theme
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * URL of the user\'s avatar image.
     * @type {string}
     * @memberof User
     */
    'avatarUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface Writing
 */
export interface Writing {
    /**
     * 
     * @type {number}
     * @memberof Writing
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Writing
     */
    'userId': number;
    /**
     * 
     * @type {number}
     * @memberof Writing
     */
    'themeId': number;
    /**
     * 
     * @type {string}
     * @memberof Writing
     */
    'content': string;
    /**
     * 
     * @type {number}
     * @memberof Writing
     */
    'durationSeconds': number;
    /**
     * 
     * @type {number}
     * @memberof Writing
     */
    'aiScore'?: number;
    /**
     * 
     * @type {string}
     * @memberof Writing
     */
    'aiFeedbackOverall'?: string;
    /**
     * 
     * @type {string}
     * @memberof Writing
     */
    'aiFeedbackClarity'?: string;
    /**
     * 
     * @type {string}
     * @memberof Writing
     */
    'aiFeedbackAccuracy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Writing
     */
    'aiFeedbackCompleteness'?: string;
    /**
     * 
     * @type {string}
     * @memberof Writing
     */
    'aiFeedbackStructure'?: string;
    /**
     * 
     * @type {string}
     * @memberof Writing
     */
    'aiFeedbackConciseness'?: string;
    /**
     * 
     * @type {string}
     * @memberof Writing
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Writing
     */
    'updatedAt': string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get current authenticated user\'s information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authenticate user and get a token
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('loginUser', 'loginRequest', loginRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sign up a new user
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signupUser: async (registerRequest: RegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerRequest' is not null or undefined
            assertParamExists('signupUser', 'registerRequest', registerRequest)
            const localVarPath = `/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get current authenticated user\'s information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Authenticate user and get a token
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginUser(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginUser(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.loginUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sign up a new user
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signupUser(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signupUser(registerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.signupUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Get current authenticated user\'s information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Authenticate user and get a token
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponse> {
            return localVarFp.loginUser(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sign up a new user
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signupUser(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponse> {
            return localVarFp.signupUser(registerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Get current authenticated user\'s information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Authenticate user and get a token
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public loginUser(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).loginUser(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sign up a new user
     * @param {RegisterRequest} registerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public signupUser(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).signupUser(registerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ThemesApi - axios parameter creator
 * @export
 */
export const ThemesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new theme
         * @param {NewThemeRequest} newThemeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTheme: async (newThemeRequest: NewThemeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newThemeRequest' is not null or undefined
            assertParamExists('createTheme', 'newThemeRequest', newThemeRequest)
            const localVarPath = `/themes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newThemeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a specific theme by ID
         * @param {number} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeById: async (themeId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeId' is not null or undefined
            assertParamExists('getThemeById', 'themeId', themeId)
            const localVarPath = `/themes/{themeId}`
                .replace(`{${"themeId"}}`, encodeURIComponent(String(themeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all available themes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listThemes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/themes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThemesApi - functional programming interface
 * @export
 */
export const ThemesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThemesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new theme
         * @param {NewThemeRequest} newThemeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTheme(newThemeRequest: NewThemeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Theme>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTheme(newThemeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemesApi.createTheme']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get details of a specific theme by ID
         * @param {number} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThemeById(themeId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Theme>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThemeById(themeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemesApi.getThemeById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of all available themes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listThemes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Theme>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listThemes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemesApi.listThemes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ThemesApi - factory interface
 * @export
 */
export const ThemesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThemesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new theme
         * @param {NewThemeRequest} newThemeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTheme(newThemeRequest: NewThemeRequest, options?: RawAxiosRequestConfig): AxiosPromise<Theme> {
            return localVarFp.createTheme(newThemeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a specific theme by ID
         * @param {number} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeById(themeId: number, options?: RawAxiosRequestConfig): AxiosPromise<Theme> {
            return localVarFp.getThemeById(themeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all available themes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listThemes(options?: RawAxiosRequestConfig): AxiosPromise<Array<Theme>> {
            return localVarFp.listThemes(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThemesApi - object-oriented interface
 * @export
 * @class ThemesApi
 * @extends {BaseAPI}
 */
export class ThemesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new theme
     * @param {NewThemeRequest} newThemeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemesApi
     */
    public createTheme(newThemeRequest: NewThemeRequest, options?: RawAxiosRequestConfig) {
        return ThemesApiFp(this.configuration).createTheme(newThemeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a specific theme by ID
     * @param {number} themeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemesApi
     */
    public getThemeById(themeId: number, options?: RawAxiosRequestConfig) {
        return ThemesApiFp(this.configuration).getThemeById(themeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all available themes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemesApi
     */
    public listThemes(options?: RawAxiosRequestConfig) {
        return ThemesApiFp(this.configuration).listThemes(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WritingsApi - axios parameter creator
 * @export
 */
export const WritingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new writing record and trigger AI review
         * @param {NewWritingRequest} newWritingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWriting: async (newWritingRequest: NewWritingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newWritingRequest' is not null or undefined
            assertParamExists('createWriting', 'newWritingRequest', newWritingRequest)
            const localVarPath = `/writings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newWritingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a specific writing record by ID
         * @param {number} writingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWritingById: async (writingId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'writingId' is not null or undefined
            assertParamExists('getWritingById', 'writingId', writingId)
            const localVarPath = `/writings/{writingId}`
                .replace(`{${"writingId"}}`, encodeURIComponent(String(writingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all writings for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserWritings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/writings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger AI review for a writing
         * @param {NewReviewRequest} newReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewWriting: async (newReviewRequest: NewReviewRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newReviewRequest' is not null or undefined
            assertParamExists('reviewWriting', 'newReviewRequest', newReviewRequest)
            const localVarPath = `/review`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newReviewRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WritingsApi - functional programming interface
 * @export
 */
export const WritingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WritingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new writing record and trigger AI review
         * @param {NewWritingRequest} newWritingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWriting(newWritingRequest: NewWritingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Writing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWriting(newWritingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WritingsApi.createWriting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get details of a specific writing record by ID
         * @param {number} writingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWritingById(writingId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Writing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWritingById(writingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WritingsApi.getWritingById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of all writings for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserWritings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Writing>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserWritings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WritingsApi.listUserWritings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Trigger AI review for a writing
         * @param {NewReviewRequest} newReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reviewWriting(newReviewRequest: NewReviewRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Writing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reviewWriting(newReviewRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WritingsApi.reviewWriting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WritingsApi - factory interface
 * @export
 */
export const WritingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WritingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new writing record and trigger AI review
         * @param {NewWritingRequest} newWritingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWriting(newWritingRequest: NewWritingRequest, options?: RawAxiosRequestConfig): AxiosPromise<Writing> {
            return localVarFp.createWriting(newWritingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a specific writing record by ID
         * @param {number} writingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWritingById(writingId: number, options?: RawAxiosRequestConfig): AxiosPromise<Writing> {
            return localVarFp.getWritingById(writingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all writings for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserWritings(options?: RawAxiosRequestConfig): AxiosPromise<Array<Writing>> {
            return localVarFp.listUserWritings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger AI review for a writing
         * @param {NewReviewRequest} newReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewWriting(newReviewRequest: NewReviewRequest, options?: RawAxiosRequestConfig): AxiosPromise<Writing> {
            return localVarFp.reviewWriting(newReviewRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WritingsApi - object-oriented interface
 * @export
 * @class WritingsApi
 * @extends {BaseAPI}
 */
export class WritingsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new writing record and trigger AI review
     * @param {NewWritingRequest} newWritingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WritingsApi
     */
    public createWriting(newWritingRequest: NewWritingRequest, options?: RawAxiosRequestConfig) {
        return WritingsApiFp(this.configuration).createWriting(newWritingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a specific writing record by ID
     * @param {number} writingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WritingsApi
     */
    public getWritingById(writingId: number, options?: RawAxiosRequestConfig) {
        return WritingsApiFp(this.configuration).getWritingById(writingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all writings for the authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WritingsApi
     */
    public listUserWritings(options?: RawAxiosRequestConfig) {
        return WritingsApiFp(this.configuration).listUserWritings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger AI review for a writing
     * @param {NewReviewRequest} newReviewRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WritingsApi
     */
    public reviewWriting(newReviewRequest: NewReviewRequest, options?: RawAxiosRequestConfig) {
        return WritingsApiFp(this.configuration).reviewWriting(newReviewRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



