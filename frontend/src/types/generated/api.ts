/* tslint:disable */
/* eslint-disable */
/**
 * Kotobalize API
 * API for the Kotobalize technical interview preparation app.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface AuthResponse
 */
export interface AuthResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthResponse
     */
    'token': string;
    /**
     * 
     * @type {User}
     * @memberof AuthResponse
     */
    'user': User;
}
/**
 * 
 * @export
 * @interface AvatarUploadRequest
 */
export interface AvatarUploadRequest {
    /**
     * 
     * @type {string}
     * @memberof AvatarUploadRequest
     */
    'fileName': string;
    /**
     * 
     * @type {string}
     * @memberof AvatarUploadRequest
     */
    'fileType': string;
}
/**
 * 
 * @export
 * @interface AvatarUploadResponse
 */
export interface AvatarUploadResponse {
    /**
     * 
     * @type {string}
     * @memberof AvatarUploadResponse
     */
    'uploadUrl': string;
    /**
     * 
     * @type {string}
     * @memberof AvatarUploadResponse
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface NewReviewRequest
 */
export interface NewReviewRequest {
    /**
     * 
     * @type {number}
     * @memberof NewReviewRequest
     */
    'writingId': number;
}
/**
 * 
 * @export
 * @interface NewThemeRequest
 */
export interface NewThemeRequest {
    /**
     * 
     * @type {string}
     * @memberof NewThemeRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof NewThemeRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof NewThemeRequest
     */
    'category': string;
    /**
     * 
     * @type {number}
     * @memberof NewThemeRequest
     */
    'timeLimitInSeconds': number;
}
/**
 * 
 * @export
 * @interface NewWritingRequest
 */
export interface NewWritingRequest {
    /**
     * 
     * @type {number}
     * @memberof NewWritingRequest
     */
    'themeId': number;
    /**
     * 
     * @type {string}
     * @memberof NewWritingRequest
     */
    'content': string;
    /**
     * 
     * @type {number}
     * @memberof NewWritingRequest
     */
    'durationSeconds': number;
}
/**
 * 
 * @export
 * @interface RegisterRequest
 */
export interface RegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Theme
 */
export interface Theme {
    /**
     * 
     * @type {number}
     * @memberof Theme
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Theme
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Theme
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Theme
     */
    'category': string;
    /**
     * 
     * @type {number}
     * @memberof Theme
     */
    'timeLimitInSeconds': number;
    /**
     * 
     * @type {string}
     * @memberof Theme
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Theme
     */
    'updatedAt': string;
    /**
     * ID of the user who created the theme. Null for official themes.
     * @type {number}
     * @memberof Theme
     */
    'creatorId'?: number;
    /**
     * Indicates if the current user has favorited this theme.
     * @type {boolean}
     * @memberof Theme
     */
    'isFavorited'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateAvatarRequest
 */
export interface UpdateAvatarRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateAvatarRequest
     */
    'avatarUrl': string;
}
/**
 * 
 * @export
 * @interface UpdateThemeRequest
 */
export interface UpdateThemeRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateThemeRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateThemeRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateThemeRequest
     */
    'category'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateThemeRequest
     */
    'timeLimitInSeconds'?: number;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * URL of the user\'s avatar image.
     * @type {string}
     * @memberof User
     */
    'avatarUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface Writing
 */
export interface Writing {
    /**
     * 
     * @type {number}
     * @memberof Writing
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Writing
     */
    'userId': number;
    /**
     * 
     * @type {number}
     * @memberof Writing
     */
    'themeId': number;
    /**
     * 
     * @type {string}
     * @memberof Writing
     */
    'content': string;
    /**
     * 
     * @type {number}
     * @memberof Writing
     */
    'durationSeconds': number;
    /**
     * The total score from 0 to 100.
     * @type {number}
     * @memberof Writing
     */
    'aiScore'?: number;
    /**
     * Detailed feedback from AI based on 5 viewpoints. This will be stored as a JSON string.
     * @type {string}
     * @memberof Writing
     */
    'aiFeedback'?: string;
    /**
     * 
     * @type {string}
     * @memberof Writing
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Writing
     */
    'updatedAt': string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get current authenticated user\'s information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authenticate user and get a token
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('loginUser', 'loginRequest', loginRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sign up a new user
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signupUser: async (registerRequest: RegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerRequest' is not null or undefined
            assertParamExists('signupUser', 'registerRequest', registerRequest)
            const localVarPath = `/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get current authenticated user\'s information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Authenticate user and get a token
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginUser(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginUser(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.loginUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sign up a new user
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signupUser(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signupUser(registerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.signupUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Get current authenticated user\'s information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Authenticate user and get a token
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponse> {
            return localVarFp.loginUser(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sign up a new user
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signupUser(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponse> {
            return localVarFp.signupUser(registerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Get current authenticated user\'s information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Authenticate user and get a token
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public loginUser(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).loginUser(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sign up a new user
     * @param {RegisterRequest} registerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public signupUser(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).signupUser(registerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ThemesApi - axios parameter creator
 * @export
 */
export const ThemesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new theme
         * @param {NewThemeRequest} newThemeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTheme: async (newThemeRequest: NewThemeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newThemeRequest' is not null or undefined
            assertParamExists('createTheme', 'newThemeRequest', newThemeRequest)
            const localVarPath = `/themes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newThemeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a theme
         * @param {number} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTheme: async (themeId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeId' is not null or undefined
            assertParamExists('deleteTheme', 'themeId', themeId)
            const localVarPath = `/themes/{themeId}`
                .replace(`{${"themeId"}}`, encodeURIComponent(String(themeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Favorite a theme
         * @param {number} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        favoriteTheme: async (themeId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeId' is not null or undefined
            assertParamExists('favoriteTheme', 'themeId', themeId)
            const localVarPath = `/themes/{themeId}/favorite`
                .replace(`{${"themeId"}}`, encodeURIComponent(String(themeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a specific theme by ID
         * @param {number} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeById: async (themeId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeId' is not null or undefined
            assertParamExists('getThemeById', 'themeId', themeId)
            const localVarPath = `/themes/{themeId}`
                .replace(`{${"themeId"}}`, encodeURIComponent(String(themeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all available themes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listThemes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/themes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unfavorite a theme
         * @param {number} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfavoriteTheme: async (themeId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeId' is not null or undefined
            assertParamExists('unfavoriteTheme', 'themeId', themeId)
            const localVarPath = `/themes/{themeId}/favorite`
                .replace(`{${"themeId"}}`, encodeURIComponent(String(themeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing theme
         * @param {number} themeId 
         * @param {UpdateThemeRequest} updateThemeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTheme: async (themeId: number, updateThemeRequest: UpdateThemeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeId' is not null or undefined
            assertParamExists('updateTheme', 'themeId', themeId)
            // verify required parameter 'updateThemeRequest' is not null or undefined
            assertParamExists('updateTheme', 'updateThemeRequest', updateThemeRequest)
            const localVarPath = `/themes/{themeId}`
                .replace(`{${"themeId"}}`, encodeURIComponent(String(themeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateThemeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThemesApi - functional programming interface
 * @export
 */
export const ThemesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThemesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new theme
         * @param {NewThemeRequest} newThemeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTheme(newThemeRequest: NewThemeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Theme>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTheme(newThemeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemesApi.createTheme']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a theme
         * @param {number} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTheme(themeId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTheme(themeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemesApi.deleteTheme']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Favorite a theme
         * @param {number} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async favoriteTheme(themeId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.favoriteTheme(themeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemesApi.favoriteTheme']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get details of a specific theme by ID
         * @param {number} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThemeById(themeId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Theme>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThemeById(themeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemesApi.getThemeById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of all available themes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listThemes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Theme>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listThemes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemesApi.listThemes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unfavorite a theme
         * @param {number} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unfavoriteTheme(themeId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unfavoriteTheme(themeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemesApi.unfavoriteTheme']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing theme
         * @param {number} themeId 
         * @param {UpdateThemeRequest} updateThemeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTheme(themeId: number, updateThemeRequest: UpdateThemeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Theme>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTheme(themeId, updateThemeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemesApi.updateTheme']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ThemesApi - factory interface
 * @export
 */
export const ThemesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThemesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new theme
         * @param {NewThemeRequest} newThemeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTheme(newThemeRequest: NewThemeRequest, options?: RawAxiosRequestConfig): AxiosPromise<Theme> {
            return localVarFp.createTheme(newThemeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a theme
         * @param {number} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTheme(themeId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTheme(themeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Favorite a theme
         * @param {number} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        favoriteTheme(themeId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.favoriteTheme(themeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a specific theme by ID
         * @param {number} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeById(themeId: number, options?: RawAxiosRequestConfig): AxiosPromise<Theme> {
            return localVarFp.getThemeById(themeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all available themes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listThemes(options?: RawAxiosRequestConfig): AxiosPromise<Array<Theme>> {
            return localVarFp.listThemes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unfavorite a theme
         * @param {number} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfavoriteTheme(themeId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unfavoriteTheme(themeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing theme
         * @param {number} themeId 
         * @param {UpdateThemeRequest} updateThemeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTheme(themeId: number, updateThemeRequest: UpdateThemeRequest, options?: RawAxiosRequestConfig): AxiosPromise<Theme> {
            return localVarFp.updateTheme(themeId, updateThemeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThemesApi - object-oriented interface
 * @export
 * @class ThemesApi
 * @extends {BaseAPI}
 */
export class ThemesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new theme
     * @param {NewThemeRequest} newThemeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemesApi
     */
    public createTheme(newThemeRequest: NewThemeRequest, options?: RawAxiosRequestConfig) {
        return ThemesApiFp(this.configuration).createTheme(newThemeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a theme
     * @param {number} themeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemesApi
     */
    public deleteTheme(themeId: number, options?: RawAxiosRequestConfig) {
        return ThemesApiFp(this.configuration).deleteTheme(themeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Favorite a theme
     * @param {number} themeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemesApi
     */
    public favoriteTheme(themeId: number, options?: RawAxiosRequestConfig) {
        return ThemesApiFp(this.configuration).favoriteTheme(themeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a specific theme by ID
     * @param {number} themeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemesApi
     */
    public getThemeById(themeId: number, options?: RawAxiosRequestConfig) {
        return ThemesApiFp(this.configuration).getThemeById(themeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all available themes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemesApi
     */
    public listThemes(options?: RawAxiosRequestConfig) {
        return ThemesApiFp(this.configuration).listThemes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unfavorite a theme
     * @param {number} themeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemesApi
     */
    public unfavoriteTheme(themeId: number, options?: RawAxiosRequestConfig) {
        return ThemesApiFp(this.configuration).unfavoriteTheme(themeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing theme
     * @param {number} themeId 
     * @param {UpdateThemeRequest} updateThemeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemesApi
     */
    public updateTheme(themeId: number, updateThemeRequest: UpdateThemeRequest, options?: RawAxiosRequestConfig) {
        return ThemesApiFp(this.configuration).updateTheme(themeId, updateThemeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete user\'s avatar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAvatar: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me/avatar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a presigned URL for avatar upload
         * @param {AvatarUploadRequest} avatarUploadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvatarUploadURL: async (avatarUploadRequest: AvatarUploadRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'avatarUploadRequest' is not null or undefined
            assertParamExists('getAvatarUploadURL', 'avatarUploadRequest', avatarUploadRequest)
            const localVarPath = `/users/me/avatar/upload-url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(avatarUploadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user\'s avatar URL
         * @param {UpdateAvatarRequest} updateAvatarRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserAvatar: async (updateAvatarRequest: UpdateAvatarRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateAvatarRequest' is not null or undefined
            assertParamExists('updateUserAvatar', 'updateAvatarRequest', updateAvatarRequest)
            const localVarPath = `/users/me/avatar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAvatarRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete user\'s avatar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserAvatar(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserAvatar(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUserAvatar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a presigned URL for avatar upload
         * @param {AvatarUploadRequest} avatarUploadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvatarUploadURL(avatarUploadRequest: AvatarUploadRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvatarUploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvatarUploadURL(avatarUploadRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getAvatarUploadURL']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update user\'s avatar URL
         * @param {UpdateAvatarRequest} updateAvatarRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserAvatar(updateAvatarRequest: UpdateAvatarRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserAvatar(updateAvatarRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserAvatar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete user\'s avatar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAvatar(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.deleteUserAvatar(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a presigned URL for avatar upload
         * @param {AvatarUploadRequest} avatarUploadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvatarUploadURL(avatarUploadRequest: AvatarUploadRequest, options?: RawAxiosRequestConfig): AxiosPromise<AvatarUploadResponse> {
            return localVarFp.getAvatarUploadURL(avatarUploadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user\'s avatar URL
         * @param {UpdateAvatarRequest} updateAvatarRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserAvatar(updateAvatarRequest: UpdateAvatarRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUserAvatar(updateAvatarRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Delete user\'s avatar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserAvatar(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUserAvatar(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a presigned URL for avatar upload
     * @param {AvatarUploadRequest} avatarUploadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getAvatarUploadURL(avatarUploadRequest: AvatarUploadRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getAvatarUploadURL(avatarUploadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user\'s avatar URL
     * @param {UpdateAvatarRequest} updateAvatarRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserAvatar(updateAvatarRequest: UpdateAvatarRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserAvatar(updateAvatarRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WritingsApi - axios parameter creator
 * @export
 */
export const WritingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new writing record and trigger AI review
         * @param {NewWritingRequest} newWritingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWriting: async (newWritingRequest: NewWritingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newWritingRequest' is not null or undefined
            assertParamExists('createWriting', 'newWritingRequest', newWritingRequest)
            const localVarPath = `/writings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newWritingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a specific writing record by ID
         * @param {number} writingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWritingById: async (writingId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'writingId' is not null or undefined
            assertParamExists('getWritingById', 'writingId', writingId)
            const localVarPath = `/writings/{writingId}`
                .replace(`{${"writingId"}}`, encodeURIComponent(String(writingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all writings for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserWritings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/writings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger AI review for a writing
         * @param {NewReviewRequest} newReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewWriting: async (newReviewRequest: NewReviewRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newReviewRequest' is not null or undefined
            assertParamExists('reviewWriting', 'newReviewRequest', newReviewRequest)
            const localVarPath = `/review`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newReviewRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WritingsApi - functional programming interface
 * @export
 */
export const WritingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WritingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new writing record and trigger AI review
         * @param {NewWritingRequest} newWritingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWriting(newWritingRequest: NewWritingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Writing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWriting(newWritingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WritingsApi.createWriting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get details of a specific writing record by ID
         * @param {number} writingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWritingById(writingId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Writing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWritingById(writingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WritingsApi.getWritingById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of all writings for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserWritings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Writing>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserWritings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WritingsApi.listUserWritings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Trigger AI review for a writing
         * @param {NewReviewRequest} newReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reviewWriting(newReviewRequest: NewReviewRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Writing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reviewWriting(newReviewRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WritingsApi.reviewWriting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WritingsApi - factory interface
 * @export
 */
export const WritingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WritingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new writing record and trigger AI review
         * @param {NewWritingRequest} newWritingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWriting(newWritingRequest: NewWritingRequest, options?: RawAxiosRequestConfig): AxiosPromise<Writing> {
            return localVarFp.createWriting(newWritingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a specific writing record by ID
         * @param {number} writingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWritingById(writingId: number, options?: RawAxiosRequestConfig): AxiosPromise<Writing> {
            return localVarFp.getWritingById(writingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all writings for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserWritings(options?: RawAxiosRequestConfig): AxiosPromise<Array<Writing>> {
            return localVarFp.listUserWritings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger AI review for a writing
         * @param {NewReviewRequest} newReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewWriting(newReviewRequest: NewReviewRequest, options?: RawAxiosRequestConfig): AxiosPromise<Writing> {
            return localVarFp.reviewWriting(newReviewRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WritingsApi - object-oriented interface
 * @export
 * @class WritingsApi
 * @extends {BaseAPI}
 */
export class WritingsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new writing record and trigger AI review
     * @param {NewWritingRequest} newWritingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WritingsApi
     */
    public createWriting(newWritingRequest: NewWritingRequest, options?: RawAxiosRequestConfig) {
        return WritingsApiFp(this.configuration).createWriting(newWritingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a specific writing record by ID
     * @param {number} writingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WritingsApi
     */
    public getWritingById(writingId: number, options?: RawAxiosRequestConfig) {
        return WritingsApiFp(this.configuration).getWritingById(writingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all writings for the authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WritingsApi
     */
    public listUserWritings(options?: RawAxiosRequestConfig) {
        return WritingsApiFp(this.configuration).listUserWritings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger AI review for a writing
     * @param {NewReviewRequest} newReviewRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WritingsApi
     */
    public reviewWriting(newReviewRequest: NewReviewRequest, options?: RawAxiosRequestConfig) {
        return WritingsApiFp(this.configuration).reviewWriting(newReviewRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



